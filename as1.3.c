#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <time.h>



void *add_item();
void *remove_item();
void *append_buffer();
void *remove_buffer();
int i;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int PRODUCERS, CONSUMERS, BUFFER_SIZE, REQUEST;
int buffer[100000];
int tail = 0, head = 0, request = 0, success = 0;
clock_t timer1, timer2;
// ระบุตัวแปรที่ฟังชั่นก์จะส่งคืน
// ฟังก์ชัน main รับint 
int main (int argc, char*argv)
{ 

        printf("PRODUCERS:\n")  ;  
        scanf("%d", &PRODUCERS);
        printf("Consumer:\n");
        scanf("%d", &CONSUMERS);
        printf("Buffer:\n");
        scanf("%d", &BUFFER_SIZE);
        printf("Request:\n");
        scanf("%d", &REQUEST);

    timer1 = clock();   //ดึง clock1 cpu ปัจจุบันมาใช้

    pthread_t thread_producer[PRODUCERS];
    pthread_t thread_consumer[CONSUMERS];

/* สร้าง loop ในการสร้าง thread producer   */
    for( i=0; i<PRODUCERS; i++){
	
        pthread_create(&thread_producer[i], NULL, append_buffer, NULL);
}
/* สร้าง loop ในการสร้าง thread consumer */
    for(i=0; i<CONSUMERS; i++){
	
        pthread_create(&thread_consumer[i], NULL, remove_buffer, NULL);
}
/* รอจนกวาthread จะเสร็จสมบูรณ์ก่อนที่main จะดำเนินการต่อ  */
/* รอ prodecers และ consumers รัน ถ้าเกิด error อะไรจะทำการหยุด    */
/* กระบวนการและ thread ทั้งหมด ก่อนจะเสร็จสมบูรณ์   */
    for(i=0; i<CONSUMERS; i++){
	
        pthread_join(thread_consumer[i], NULL);
}
    for(i=0; i<PRODUCERS; i++){
	
        pthread_join(thread_producer[i], NULL);
}
    timer2 = clock();   //ดึง clock2 cpu ปัจจุบันมาใช้
    float elapsed = ((float)(timer2 - timer1) / CLOCKS_PER_SEC);

    printf("\n");
    printf("Producers %d, Consumers %d\n", PRODUCERS, CONSUMERS);
    printf("Buffer size %d\n", BUFFER_SIZE);
    printf("Requests %d\n\n", request);
    printf("Successfully consumed %d requests (%.1f%%)\n", success, (float)success * 100 / request);
    printf("Elapsed Time %.2f s\n", elapsed);
    printf("Throughput %.2f successful requests/s\n", (float)(success) / elapsed);

    exit(EXIT_SUCCESS);
}

void *add_item() { //สร้างฟังก์ชั่น add_item
    buffer[head++] = 1;//buffer[head++]มีค่า=1;             
    head = head % BUFFER_SIZE; //head = head หารเอาแต่เศษ buffer_size
}

void *remove_item() {//สร้างฟังก์ชั่น remove_item
    buffer[tail++] = 0;//buffer[tail++]มีค่า=0
    tail = tail % BUFFER_SIZE;//tail มีค่าเท่ากับ tail / buffer_size เอาแต่เศษ
}

void *append_buffer() {//สร้างฟังก์ชั่น append_buffer
    printf("Append thread number %ld\n", pthread_self());//print ค่า thread ที่เรียกใช้
    while(request<REQUEST) {//ถ้า request<REQUTEST จะเข้าloop while 
        if(!pthread_mutex_trylock(&mutex) && request<REQUEST) {//สิทธิ์ในการแก้ไขบัฟเฟอร์ ถ้าไม่ตรงตามเงื่อนไขจะล็อค
            if(buffer[head] == 0) {
                add_item();
                request++;
                printf(" + thread %ld append success\n", pthread_self());
            }
            else {//ถ้าไม่ใช่ แสดง buffer overflow 
            printf("Buffer overflow\n");
            }
            pthread_mutex_unlock(&mutex);// ปลดล็อคmutex
        }
    }
    pthread_exit(NULL);
}

void *remove_buffer() {
    printf("Remove thread number %ld\n", pthread_self());
    while(success<REQUEST) {//ในขณะที่ success มีค่าน้อยกว่า request
        if(!pthread_mutex_trylock(&mutex) && success<REQUEST) {// ถ้า pthread ไม่พยายามล็อค mutex และ success < Request จะเข้าลูป if
            if(buffer[tail] == 1) {
                remove_item();
                success++;
                printf(" - thread %ld remove success\n", pthread_self());
            }
            else {
            printf("Buffer underflow\n");
            }
            pthread_mutex_unlock(&mutex);
        }
    }
    pthread_exit(NULL);
}
